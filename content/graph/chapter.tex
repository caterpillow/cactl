\chapter{Graph}

\subsection{Theorems}

  	A matching $M$ is maximum **iff** there is no $M$-augmenting path. \\

	\subsection{Hall's Marriage Theorem}
		$G = (L, R; E)$ has a matching covering all of $L$ iff $|N(s)| \ge |S|$ for every $S \subseteq L$. \\
		Corollary: Let $\delta=\max_{S\subseteq L}\big(|S|-|N(S)|\big)$. The size of the maximum matching is $\tau = |L|-\delta$. \\

	\subsection{Kőnig's Theorem}
 		In bipartite graphs: **max matching = min vertex cover**, i.e. $\nu(G)=\tau(G)$.
		Hence max independent set size $\alpha(G)=|V|-\tau(G)=|V|-\nu(G)$. \\

		To recover min vertex cover: 
		From all unmatched vertices in $L$, BFS alternating paths (use non-matching edges $L\!\to\!R$; matching edges $R\!\to\!L$).
		Let $Z$ be reachable vertices. Min vertex cover is $(L\setminus Z)\cup(R\cap Z)$. \\

	\subsection{Dilworth's Theorem (posets)}
		Run Floyd-Warshall for transitivity. \\
		Width (max antichain size) = min number of chains in a partition. \\
		Reduction: make bipartite graph with two copies of elements; edge $x_L\!-\!y_R$ if $x<y$. Then
		min chain decomposition size $= |P|-\nu$; width $= |P|-(|P|-\nu)=\nu$. \\
		Mirsky’s Theorem (dual): Height (max chain size) = min number of antichains in a partition. \\

	\subsection{Tutte’s 1-Factor Theorem}
		$odd(G)$ is the number of components in $G$ with an odd number of vertices. 
		$G$ has a perfect matching iff for all $S\subseteq V$, $\text{odd}(G-S)\le |S|$.
		Tutte–Berge formula: $\displaystyle \nu(G)=\tfrac12\min_{S\subseteq V}\big(|V|-\text{odd}(G-S)+|S|\big)$. \\

	\subsection{Edge cover}
		In any graph without isolated vertices, the size of the minimum edge cover (set of edges that touch every vertex) is given by: \[\rho'(G)=|V|-\nu(G)\]. \\

\section{Fundamentals}
	\kactlimport{BellmanFord.h}
	\kactlimport{DEsopoPape.h}
	\kactlimport{FloydWarshall.h}
	\kactlimport{DirectedCycle.h}
	% \kactlimport{TopoSort.h} % if u mess this up u should retire

\section{Network flow}
	\kactlimport{FordFulkerson.h}
	\kactlimport{EdmondsKarp.h}
	\kactlimport{Dinic.h}
	\kactlimport{PushRelabel.h}
	\kactlimport{MinCostMaxFlow.h}
	\kactlimport{MinCut.h}
	\kactlimport{GlobalMinCut.h}
	\kactlimport{NetworkSimplex.h} % TO LEARN HOW IT ACTUALLY WORKS (i think i can use it?)
	\kactlimport{GomoryHu.h} % TO LEARN

\section{Matching}

	\subsection{Reductions}
	
	\subsubsection{Min cut reduction}
		Consider min cut as an instance of this problem: 
		Given $A[N]$ and $B[N]$ (any sign) and $C[N][N]$ (non-negative), find a binary string $S$ of length $N$ that minimises the following: \\
		\begin{itemize}[noitemsep]
		\item Pay $A[i]$ if $S[i] = 1$ 
		\item Pay $B[i]$ if $S[i] = 0$ 
		\item Pay $C[i][j]$ if $S[i] = 1$ and $S[j] = 0$. 
		\end{itemize}
		To calculate the answer: 
		\begin{itemize}[noitemsep]
		\item Add edges $i$ to $t$ of capacity $B[i] + \texttt{inf}$. 
		\item Add edges $s$ to $i$ of capacity $A[i] + \texttt{inf}$. 
		\item Add edges $i$ to $j$ of capcity $C[i][j]$. 
		\item The answer is the maximum flow in this graph minus $n \times \texttt{inf}$. 
		\end{itemize}

	\subsection{Circulation}
	

	\kactlimport{DFSMatching.h}
	\kactlimport{MinimumVertexCover.h}
	\kactlimport{hopcroftKarp.h}
	\kactlimport{WeightedMatching.h}
	\kactlimport{GeneralMatching.h} % redundant
	\kactlimport{Blossom.h}

\section{DFS algorithms}
	\kactlimport{SCC.h}
	\kactlimport{BiconnectedComponents.h}
	\kactlimport{BlockCutTree.h}
	\kactlimport{2sat.h}
	\kactlimport{EulerWalk.h}
	\kactlimport{DominatorTree.h}

\section{Coloring}
	\kactlimport{EdgeColoring.h} % idk what this is even for

\section{Heuristics}
	\kactlimport{MaximalCliques.h} % idk how useful this is
	\kactlimport{MaximumClique.h}
	\kactlimport{MaximumIndependentSet.h}

\section{Trees}
	\kactlimport{BinaryLifting.h} % probably unnecessary
	\kactlimport{LCA.h}
	\kactlimport{VirtualTree.h}
	\kactlimport{HLD.h}
	\kactlimport{CentroidDecomp.h}
	\kactlimport{LinkCutTree.h} % pls dont need this
	\kactlimport{DirectedMST.h} % pls dont need this
	\kactlimport{LongestPath.h}

\section{Other}
	\kactlimport{KthWalk.h}
	\kactlimport{MatroidIntersection.h}


\section{Math}
	\subsection{Number of Spanning Trees}
		% I.e. matrix-tree theorem.
		% Source: https://en.wikipedia.org/wiki/Kirchhoff%27s_theorem
		% Test: stress-tests/graph/matrix-tree.cpp
		Create an $N\times N$ matrix \texttt{mat}, and for each edge $a \rightarrow b \in G$, do
		\texttt{mat[a][b]---, mat[b][b]++} (and \texttt{mat[b][a]---, mat[a][a]++} if $G$ is undirected).
		Remove the $i$th row and column and take the determinant; this yields the number of directed spanning trees rooted at $i$
		(if $G$ is undirected, remove any row/column).

	\subsection{Erdős–Gallai theorem}
		% Source: https://en.wikipedia.org/wiki/Erd%C5%91s%E2%80%93Gallai_theorem
		% Test: stress-tests/graph/erdos-gallai.cpp
		A simple graph with node degrees $d_1 \ge \dots \ge d_n$ exists iff $d_1 + \dots + d_n$ is even and for every $k = 1\dots n$,
		\[ \sum _{i=1}^{k}d_{i}\leq k(k-1)+\sum _{i=k+1}^{n}\min(d_{i},k). \]
